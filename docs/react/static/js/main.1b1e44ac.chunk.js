(this["webpackJsonpreact-app"]=this["webpackJsonpreact-app"]||[]).push([[0],{252:function(e,t,n){"use strict";n.r(t);var a=n(1),r=n.n(a),o=n(23),i=n.n(o),s=(n(30),n(20)),c=(n(31),n(5)),h=n(6),l=n(8),d=n(7),p=(n(32),n(12)),m=n(0),j=function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){var e;Object(c.a)(this,n);for(var a=arguments.length,r=new Array(a),o=0;o<a;o++)r[o]=arguments[o];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsx)("div",{children:Object(m.jsx)("nav",{children:Object(m.jsx)("div",{children:Object(m.jsxs)("ul",{children:[Object(m.jsx)("li",{children:Object(m.jsx)(p.b,{to:"/",children:"Home"})}),Object(m.jsx)("li",{children:Object(m.jsx)(p.b,{to:"/project-initialization",children:"Project initialization"})}),Object(m.jsx)("li",{children:Object(m.jsx)(p.b,{to:"/simple-component",children:"Component Example"})}),Object(m.jsx)("li",{children:Object(m.jsx)(p.b,{to:"/props-component",children:"Component Parameters"})}),Object(m.jsx)("li",{children:Object(m.jsx)(p.b,{to:"/slots-component",children:"Component Projection"})}),Object(m.jsx)("li",{children:Object(m.jsx)(p.b,{to:"/extend-component",children:"Extending components"})}),Object(m.jsx)("li",{children:Object(m.jsx)(p.b,{to:"/",children:"Service"})}),Object(m.jsx)("li",{children:Object(m.jsx)(p.b,{to:"/directives-component",children:"Directives"})})]})})})})}}]),n}(a.Component),u=(n(39),function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){return Object(c.a)(this,n),t.apply(this,arguments)}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsx)("div",{className:"topbar",children:Object(m.jsx)("h1",{children:"React page"})})}}]),n}(a.Component)),b=n(2),x=n.n(b),v=function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){return Object(c.a)(this,n),t.apply(this,arguments)}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{children:[Object(m.jsx)("h1",{children:"Component Introduction"}),Object(m.jsxs)("p",{children:['React is build of "Elements" which are the smallest building blocks of the application. Elements are parts of something larger that could be called a "Component" but that will be presented later. React Element is a plain object managed by React DOM. All that elements are attached to the single root element in the HTML file. Using ',Object(m.jsx)("code",{children:"ReactDOM.render()"})," method we can pass that small element into a root DOM node. That element is immutable so it won't be changed after it is rendered. It of course can be changed but that will be explained later."]}),Object(m.jsx)(x.a,{className:"xml",children:"<html>\n    <body>\n        <div id=\"root\"></div>\n        <script>\n            const element = <h1>Hello React!</h1>;\n            ReactDOM.render(element, document.getElementById('root'));\n        <\/script>\n    </body>\n</html>"}),Object(m.jsxs)("p",{children:['Term "Component" is very often used in modern web development. In React it could be considered as a independent, reusable piece of code. They are like functions in JavaScript that can accept props and return other React elements. We can define a component using ES6 class syntax. Each React component should extend ',Object(m.jsx)("code",{children:"React.Component"})," class. As you could see in the code above we have a ",Object(m.jsx)("code",{children:"h1"})," element that was written with JSX syntax. It is neither a string nor HTML - it is just a JSX element. That provides us a template mechanism for our components."]}),Object(m.jsx)("h2",{children:"Single File Component"}),Object(m.jsxs)("p",{children:['To keep our components small we can put them into separate files. React components are stored inside ".js" files. Each React component class need to extend ',Object(m.jsx)("code",{children:"React.Component"})," class and the only method that we must define is ",Object(m.jsx)("code",{children:"render()"})," method. Other methods are optional."]}),Object(m.jsx)(x.a,{className:"javascript",children:"class SingleComponentSelector extends React.Component {\n    render() {\n        return <h1>Hello from React SFC</h1>\n    }\n}"}),Object(m.jsx)("p",{children:"Render method is one of the most important methods of a React component. It is used to return a React element. React DOM is trying to update the DOM tree according to the return value of the render method."}),Object(m.jsx)("h2",{children:"Component usage"}),Object(m.jsx)("p",{children:"To render that component we have back to the beginning of the article where we defined an Element with H1 tag. Now to see that component we have to pass it ClassName as a name of the tag."}),Object(m.jsx)(x.a,{className:"javascript",children:"const element = <SingleComponentSelector />;\nReactDOM.render(element, document.getElementById('root'));"})]})}}]),n}(a.Component),f=[{path:"/",name:"Home Page",component:function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){var e;Object(c.a)(this,n);for(var a=arguments.length,r=new Array(a),o=0;o<a;o++)r[o]=arguments[o];return(e=t.call.apply(t,[this].concat(r))).state={welcomeMessage:"Hello React"},e}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{children:[Object(m.jsx)("h1",{children:this.state.welcomeMessage}),Object(m.jsx)("p",{children:"In general this is a JavaScript library for building user interfaces. React has been released in 2013 by Jordan Walke from Facebook company. It is mostly used to create interactive Single Page Applications (SPA). Why React is so popular? Because it start using Virtual DOM (Document Object Model) to render the UI. All the DOM manipulation is done in JavaScript so React is very fast but keeps in memory the whole DOM tree. This approach with JavaScript everywhere caused that React start using the JSX (JavaScript XML) syntax to write the UI. Using that approach user can write the HTML code directly in the JavaScript."}),Object(m.jsx)("p",{children:"It is the most popular JavaScript framework for building user interfaces. Used by Facebook, Instagram, Microsoft, Netflix, PayPal, and many more. Using React you can start creating Component-Based Applications that could be very fast and scalable. Encapsulated components helps you to organize your code and reuse it. Declarative views helps you to create interactive user interfaces and keeping the state of your application without too much effort."}),Object(m.jsx)("p",{children:"React is very popular so it has also many additional libraries and tools that can extend the functionality of your application. Community of React developers is very big and it is very easy to find the best solution for any trouble. Base React library is responsible for the rendering of the view layer. So to create more complex applications you have to find the additional packages that will help you to create the more advanced components."})]})}}]),n}(a.Component),exact:!0},{path:"/project-initialization",name:"Project Initialization",component:function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){return Object(c.a)(this,n),t.apply(this,arguments)}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{children:[Object(m.jsx)("h1",{children:"Project initialization"}),Object(m.jsxs)("p",{children:['To start working with React we can just add the core library to our page. But for more complex projects we need to use a specific tool. The easiest to start with is "',Object(m.jsx)("a",{href:"https://github.com/facebook/create-react-app",children:"Create React App"}),'" tool that helps us to create a new React project.']}),Object(m.jsx)("h2",{children:"Installation and Creation of React Application"}),Object(m.jsx)("p",{children:"Using that tool we can easly create a new React project. Just type the following command:"}),Object(m.jsx)("code",{children:"npx create-react-app framweork-hero"}),Object(m.jsx)("h2",{children:"Running the development server"}),Object(m.jsx)("p",{children:"Then to run the development server we need run one of the npm scripts:"}),Object(m.jsx)("code",{children:"npm run start"})]})}}]),n}(a.Component),exact:!0},{path:"/simple-component",name:"Simple Component",component:v,exact:!0},{path:"/props-component",name:"Props Component",component:function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){return Object(c.a)(this,n),t.apply(this,arguments)}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{children:[Object(m.jsx)("h1",{children:"Component data, methods and properties"}),Object(m.jsx)("p",{children:'React Components are special objects that could have properties and methods. We can treat them as a ES6 classes. They receives external properties that are often called as "props". That are something similar to the attributes of HTML elements that can be used to customize the component.'}),Object(m.jsx)("h2",{children:"Component internal data"}),Object(m.jsxs)("p",{children:['Each component could have its "state" that allows them to keep something in memory. To do that we must define the "state" property in the constructor. Because we are extending the React.Component class we have to keep in mind that the constructor receives the "props" argument and the super() method must be called with that argument. Using JSX syntax we can access to out state variables using',Object(m.jsx)("code",{children:"this.state.welcomeMessage"})," reference that is placed within",Object(m.jsx)("code",{children:"{ }"})," braces. That inform the renderer method to place there a value of that variable."]}),Object(m.jsx)(x.a,{className:"javascript",children:"export default ExampleProps extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            welcomeMessage: 'React property!',\n        }\n    }\n    render() {\n        return <h1>Hello from {this.state.welcomeMessage}</h1>\n    }\n}"}),Object(m.jsx)("h2",{children:"Passing properties"}),Object(m.jsx)("p",{children:'This time I should explaining with passing a external properties to the component but to keep it organized like it is presented in other frameworks I had to start from the "state" property. But let\'s go to "props"! Props as it was mentioned at the beginning are the external properties that we can pass to the component. By default they are accessible within the component using the "this.props" reference. But if we create a constructor method we have to remember to call the super() method with the "props" argument to not lose the reference to the "props" object. What is more the basic React component could be a simple function that receives the "props" as the argument and return the JSX code. That kind of component is called a "function component".'}),Object(m.jsx)(x.a,{className:"javascript",children:"function FunctionComponent(props) {\n    return <h1>Hello from {props.framework}</h1>;\n}"}),Object(m.jsx)("p",{children:'This time we are not defining the "props" that we are going to receive. We can add some props to the render method but we have to be aware that it must be provided during the component creation.'}),Object(m.jsx)(x.a,{className:"javascript",children:"export default ExampleProps extends React.Component {\n    render() {\n        return <h1>Hello from {this.props.welcomeMessage}</h1>\n    }\n}"}),Object(m.jsx)(x.a,{className:"javascript",children:'element = <ExampleProps welcomeMessage="React child component" />\n'}),Object(m.jsxs)("p",{children:["Wen we call ReactDOM.render() method the ",Object(m.jsx)("code",{children:"ExampleProps"})," component is going to be rendered with the ",Object(m.jsx)("code",{children:"welcomeMessage"}),' property received from parent element. So it will render the header with text: "Hello from React child component".']}),Object(m.jsx)("h3",{children:"Passing Variables"}),Object(m.jsxs)("p",{children:["Using the same approach we can pass variables to the JSX template we can pass it to the child component. In this case we are going to pass the variable ",Object(m.jsx)("code",{children:"framework"}),"to the child ExampleProps component. It is very simple and easy to understand because it is based on plain JavaScript and JSX methodology. Knowning that simple relation we are able to provide variables to our components."]}),Object(m.jsx)(x.a,{className:"javascript",children:"export default PropsParent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            framework: 'React',\n        }\n    }\n    render() {\n        return <ExampleProps welcomeMessage={this.state.framework} />\n    }\n}"}),Object(m.jsx)("h2",{children:"Emitting Events"}),Object(m.jsx)("p",{children:"In the previous section we have seen how to pass properties to the component. But sometimes we need to emit events to the parent component. In React that could be more complex but I will try to explain it as simple as possible."}),Object(m.jsxs)("p",{children:['From the beginning we have to create a method inside SingleEmit component that will be called when the button is clicked. To intercept the onClick event we are going to use the "onClick" attribute on the button tag. Now because we want to use methods inside a class we have to use ',Object(m.jsx)("code",{children:"{ }"}),"braces to inform render method that we are going to use a JavaScript there."]}),Object(m.jsxs)("p",{children:["We are going to create a arrow function that will invoke the ",Object(m.jsx)("code",{children:"increaseNumber()"}),"method whenever the button is clicked. That method will increase the state of the",Object(m.jsx)("code",{children:"currentValue"}),' property of the SingleEmit component. Then we are going to emit the event to the parent. To do that we are going to use the "this.props" reference and then the ',Object(m.jsx)("code",{children:"increasedEvent"})," property will be the name of the event that we are going to emit. Because we want to pass the current value of that coutner to the parent we provide the reference to the ",Object(m.jsx)("code",{children:"currentValue"})," property as the function argument."]}),Object(m.jsx)(x.a,{className:"javascript",children:"export default SingleEmit extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            currentValue: 0,\n        }\n    }\n\n    increaseNumber() {\n        this.setState({currentValue: this.state.currentValue + 1});\n        this.props.increasedEvent(this.state.currentValue);\n    }\n\n    render() {\n        return <button onClick={() => this.increaseNumber()}>Increase number</button>\n    }\n}"}),Object(m.jsxs)("p",{children:["Now everything is ready to intercept that event form the parent component. To do that we will add ",Object(m.jsx)("code",{children:"increasedEvent"})," property to ",Object(m.jsx)("code",{children:"SingleEmit"}),"component definition. Like before with ",Object(m.jsx)("code",{children:"onClick"})," event again we are using JavaScript arrow function to intercept the event and invoke the ",Object(m.jsx)("code",{children:"onIncreased"}),"method. This time the arrow function will receive the current value of the counter and that value will be passed to the method that will change the state of the counter state property."]}),Object(m.jsx)(x.a,{className:"javascript",children:"export default SingleEmitParent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            counter: 0,\n        }\n    }\n\n    onIncreased(value) {\n        this.setState({counter: value});\n    }\n    \n    render() {\n        return (<div>\n            <p>Clicked: {this.state.counter} times.</p>\n            <SingleEmit increasedEvent={(event) => this.onIncreased(event)}/>\n        </div>)\n    }\n}"}),Object(m.jsxs)("p",{children:["When the ",Object(m.jsx)("code",{children:"onIncreased()"})," and ",Object(m.jsx)("code",{children:"setState()"})," methods are called the value rendered in the template will be updated."]})]})}}]),n}(a.Component),exact:!0},{path:"/slots-component",name:"Slots Component",component:function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){return Object(c.a)(this,n),t.apply(this,arguments)}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{children:[Object(m.jsx)("h1",{children:"Content projection"}),Object(m.jsxs)("p",{children:["As in other frameworks we are able to pass other components into the slots of the component. To do that we have to use ",Object(m.jsx)("code",{children:"children"}),"property from the ",Object(m.jsx)("code",{children:"props"})," component object. That will inform render method to put there the children elements (elements between",Object(m.jsx)("code",{children:"Child"})," tag) provided by the parent."]}),Object(m.jsx)("h2",{children:"React children"}),Object(m.jsx)(x.a,{className:"javascript",children:"export default Child extends React.Components {\n    render() {\n        return (\n            <div>\n                <h1>Header of child</h1>\n                <div>{this.props.children}</div>\n                <footer>Footer of child</footer>\n            </div>\n        )\n    }\n\n} "}),Object(m.jsx)(x.a,{className:"javascript",children:"export default Parent extends React.Components {\n    render() {\n        return (\n            <div>\n                <Child>\n                    <section>\n                        <h2>Parent section to be displayed</h2>\n                        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>\n                    </section>\n                </Child>\n            </div>\n        )\n    }\n} "}),Object(m.jsx)("h2",{children:"Multiple-slots"}),Object(m.jsx)("p",{children:'React allows us to use multiple slots called "named children". It works very similar like in other frameworks.'}),Object(m.jsx)(x.a,{className:"javascript",children:"export default Child extends React.Components {\n    render() {\n        return (\n            <div>\n                <div>{this.props.children.header}</div>\n                <div>{this.props.children.default}</div>\n                <footer>Footer of child</footer>\n            </div>\n        )\n    }\n\n} "}),Object(m.jsx)(x.a,{className:"javascript",children:"export default Parent extends React.Components {\n    render() {\n        return (\n            <div>\n                <Child>\n                {{\n                    header: <h2>Parent section to be displayed</h2>,\n                    default: <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>\n                }}\n                </Child>\n            </div>\n        )\n    }\n} "})]})}}]),n}(a.Component),exact:!0},{path:"/extend-component",name:"Extend Component",component:function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){return Object(c.a)(this,n),t.apply(this,arguments)}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{children:[Object(m.jsx)("h1",{children:"Extending the component"}),Object(m.jsxs)("p",{children:['Authors of the React framework recommend to follow the pattern of "Composition over Inheritance" to provide some logic to our components. This is augmented by powerful composition model of React. Based on their experience, they declare that during the creation of Facebook page they haven\'t found any use case where the component Inheritance will be a good idea. (',Object(m.jsx)("a",{href:"https://reactjs.org/docs/composition-vs-inheritance.html",children:"Source"}),")."]}),Object(m.jsxs)("p",{children:["Of course it is possible by extending the other React component class. The first one extends the ",Object(m.jsx)("code",{children:"Component"})," class from React core but this component should not have the render method. The child class will inheritance the methods from the parent class but is must have this missing render method. It is more for creating an abstraction layer to your design but it may provide an additional complexity to your code."]}),Object(m.jsx)(x.a,{className:"javascript",children:"class ParentAbstractComponent extends React.Component {\n  greet() {\n    console.log('Hello world!')\n  }\n}\n\nclass ChildComponent extends ParentAbstractComponent {\n  render () {\n    return(\n      <div>\n        <button onClick={this.greet.bind(this)}>\n          Say hello\n        </button>\n      </div>\n    )\n  }  \n} "}),Object(m.jsxs)("p",{children:['Developer can\'t "override" the render method but he can use ',Object(m.jsx)("code",{children:"props"}),"to pass the additional data and change the behavior of the component."]}),Object(m.jsx)("h2",{children:"High order components HOC"}),Object(m.jsx)("p",{children:"For many components that share the similar behavior, it is possible to create a High-Order Component (HOC) to wrap the component and provide additional functionality. HOCs are functions that take a component and return a new component with new features. That common behavior will be defined once and composed into classes that require it."}),Object(m.jsx)("p",{children:'This HOC function takes a component class as a parameter and returns a new component class that has a new functionality. It is similar to the "Decorator" pattern known from the Object-Oriented Programming. It is advanced technique for reusing component logic that evolved from the React base. Previously to resolve the multi level design problems in the React, the developers used the "mixins".'}),Object(m.jsx)(x.a,{className:"javascript",children:"const Loader = (promiseProp, Wrapped) => class extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {loading: true, error: null, result: null};\n  }\n\n  componentDidMount() {\n      this.props[promiseProp].then(\n          value => this.setState({loading: false, result: value}),\n          error => this.setState({loading: false, error})\n      );\n  }\n\n  render() {\n      if (this.state.loading) {\n          return <p>Loading. Please wait...</p>;\n      } else if (!!this.state.error) {\n          return <p>Error: {this.state.error.message}</p>;\n      } else {\n          return <Wrapped {...this.props} {this.state.result} />;\n      }\n  }\n};\n"}),Object(m.jsx)(x.a,{className:"javascript",children:"let AsyncWeatherWidget = Loader(\"weather\", Weather);\n  ... \n\n  <AsyncWeatherWidget weather={fetchWeather('/api/krakow.json')}/>\n"}),Object(m.jsx)("p",{children:"HOC Components doesn't modify the input component but it is wrapping it into a new container component. Wrapped component receives all the props from the container with the addition of the result of the promise."}),Object(m.jsxs)("p",{children:["More detailed information about HOCs can be found in the ",Object(m.jsx)("a",{href:"https://reactjs.org/docs/higher-order-components.html",children:"official documentation"}),"of the React. During the explanation of the HOCs I based on the article from ",Object(m.jsx)("a",{href:"http://natpryce.com/articles/000814.html",children:"Natpryce.com"})]})]})}}]),n}(a.Component),exact:!0},{path:"/directives-component",name:"Directives Component",component:function(e){Object(l.a)(n,e);var t=Object(d.a)(n);function n(){var e;Object(c.a)(this,n);for(var a=arguments.length,r=new Array(a),o=0;o<a;o++)r[o]=arguments[o];return(e=t.call.apply(t,[this].concat(r))).state={ren:[11,22,33]},e}return Object(h.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{children:[Object(m.jsx)("h1",{children:"Directives? What is it?"}),Object(m.jsx)("p",{children:"If you are looking for directives in the React application you may find it difficult."}),Object(m.jsx)("p",{children:"React keep the state of the Virtual DOM so it is responsible for rendering and generating the DOM elementns. This is the fundamental principle how the React works. There is no reason to use something you may known from the Angular or Vue.js framework like directives that are attached to HTML tags because there is no DOM elements where that directive could be attached. When you are providing a attribute for your React component it is treated as property that is passed to the component."}),Object(m.jsx)("h2",{children:"Dynamic CSS classes"}),Object(m.jsx)("p",{children:'Ok so we know that we do not have any directives available in the React.js framework. But how to handle the same issues that Angular and Vue.js handle with directives? The answer is "use JavaScript". React take advantage of the JavaScript and we can use it to create a functions that will provide the expected behavior.'}),Object(m.jsx)(x.a,{className:"javascript",children:'render() {\n    return (\n        <div className={`selected ${this.isAdmin() ? "" : "disabled"}`}>\n            Hello User!\n        </div>\n    )\n}'}),Object(m.jsx)("p",{children:"When the state of a component changes, React performs a re-render and in that moment we pass the respective CSS classes to our div."}),Object(m.jsx)("h2",{children:"Dynamic Inline-styling"}),Object(m.jsx)("p",{children:"This time we will also bind the expression to the style attribute. Because everything in React is an JavaScript we can easily assing specific object to that attribute using the assignment operator."}),Object(m.jsx)(x.a,{className:"javascript",children:'export default InputLabel extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            inputStyles: {\n                color: this.props.disabled ? "#999" : "#000",\n                font-weight: this.props.required ? "bold" : "normal"\n            }\n        }\n    }\n                \n    render() {\n        return (\n            <span style={this.state.inputStyles}>Label text</span>\n        )\n    }\n}'}),Object(m.jsx)("p",{children:'In this example depending on the provided properties we can change the style of the input label. If we pass the required property the "Label text" will be bolded. In inputStyles object we manipulate the CSS selectors and base on the state of the component we can change them to specific value. In JSX we only need to bind the style attribute with the reference of that object. We have to remember that the "style" behave like a property in React.js instead of an classic attribute.'}),Object(m.jsx)("h2",{children:"Conditional rendering"}),Object(m.jsxs)("p",{children:['Again we have to use the clear JavaScript to render a specific HTML code but this time we can use the "if" statement. If the condition is true we will render the',Object(m.jsx)("code",{children:"span"})," block with the basket size information. Otherwise this block will return null that will not be rendered."]}),Object(m.jsx)(x.a,{className:"javascript",children:"render() {\n    return (\n        {this.state.basketItems > 0 && <span>You have {this.state.basketItems} items in your basket.</span>}\n    )\n}"}),Object(m.jsx)("p",{children:"Here we can see that the amount of items in basket is displayed only when there is more than 0 items."}),Object(m.jsx)("p",{children:"In JSX we can use ternary operator to show two code blocks depending on the condition result."}),Object(m.jsx)(x.a,{className:"javascript",children:"render() {\n    return (\n        {this.state.basketItems > 0\n            ? <span>You have {this.state.basketItems} items in your basket.</span>\n            : <span>Your basket is empty.</span>\n        }\n    )\n}"}),Object(m.jsx)("h2",{children:"Rendering the list"}),Object(m.jsx)("p",{children:'Finally sometimes we need to render a list of items. Again in this case we can\'t use directly a "for" directive but we can think of it as a JavaScript code and we can use the "map" function to iterate over the list.'}),Object(m.jsx)(x.a,{className:"javascript",children:"render() {\n    return (\n        {this.state.basketProducts.map((item) => <div>{item.name}</div>)}\n    )\n}"}),Object(m.jsxs)("p",{children:["In this case we want to present the list of orders and each order will be represented by a",Object(m.jsx)("code",{children:"div"})," element that innerText will be the name property of the order."]}),Object(m.jsx)("p",{children:"Using map we can return the zero-based index of the item in the list. So we can get the index of the item variable that we used in the JSX. To do that we can extract the second argument form map method and then use it as a variable."}),Object(m.jsx)(x.a,{className:"javascript",children:"render() {\n    return (\n        {this.state.basketProducts.map((item, i) => <div>{i+1}: {item.name}</div>)}\n    )\n}"}),Object(m.jsx)("p",{children:"Sometimes we want to render a dynamic list of items that can be changed when the component receives new data. In this case every change in the data array will cause the whole list to be re-rendered. To prevent this we can use the key property that is responsible for tracking changes in the data array. To do that we only have to bind the key attribute with proper value. In this case we want to use the id of the item as a key."}),Object(m.jsx)(x.a,{className:"javascript",children:"render() {\n    return (\n        {this.state.basketProducts.map((item, i) => <div key={item.id}>{i+1}: {item.name}</div>)}\n    )\n}"}),Object(m.jsx)("p",{children:"In React this list rendering syntax within JSX may be too long and can be hard to read. So if we want to provide more complex list rendering we can create a specific function or variable that will be responsible for rendering the list in a clear way."}),Object(m.jsx)(x.a,{className:"javascript",children:"render() {\n    const itemsList = this.state.basketProducts.map((item, i) => \n        <div key={item.id}>{i+1}: {item.name}</div>);\n    return (\n        <header>{itemsList}</header>\n    );\n}"})]})}}]),n}(a.Component),exact:!0}],O=n(3);var w=function(){return Object(m.jsx)("div",{children:Object(m.jsxs)(p.a,{children:[Object(m.jsx)(j,{}),Object(m.jsx)("header",{children:Object(m.jsx)(u,{})}),Object(m.jsx)("main",{children:Object(m.jsx)("section",{children:Object(m.jsx)(O.c,{children:f.map((function(e,t){return Object(m.jsx)(O.a,{path:e.path,exact:e.exact,render:function(t){return Object(m.jsx)(e.component,Object(s.a)(Object(s.a)({},t),e.props))}},t)}))})})}),Object(m.jsx)("footer",{})]})})},g=function(e){e&&e instanceof Function&&n.e(3).then(n.bind(null,253)).then((function(t){var n=t.getCLS,a=t.getFID,r=t.getFCP,o=t.getLCP,i=t.getTTFB;n(e),a(e),r(e),o(e),i(e)}))};i.a.render(Object(m.jsx)(r.a.StrictMode,{children:Object(m.jsx)(w,{})}),document.getElementById("root")),g()},30:function(e,t,n){},31:function(e,t,n){},32:function(e,t,n){},39:function(e,t,n){}},[[252,1,2]]]);
//# sourceMappingURL=main.1b1e44ac.chunk.js.map